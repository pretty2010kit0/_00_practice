这个包主要研究类加载机制与反射。

当我们调用Java命令运行某个Java程序时，将会启动一个Java虚拟机进程，
不管该Java程序有多么复杂，该程序启动了多少线程，它们都处于该Java
虚拟机进程里。
同一个JVM的所有线程，所有变量都处于同一个进程里，它们都使用JVM进程
的内存区。
当系统出现以下几种情况时，JVM进程将被终止。
1）程序运行到最后正常结束。
2）程序运行到使用System.exit()或Runtime.getRuntime().exit()代码处结束。
3）程序执行过程中遇到未捕获的异常或错误而结束。
4）程序所在平台强制结束了JVM进程。
JVM进程结束，该进程在内存中的状态将会丢失。

-------
当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过
加载，连接，初始化3个步骤对该类进行初始化。

--类的加载
类加载指的是将类的class文件读入内存，并为之建立一个java.lang.Class
对象。也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang
.Class对象。

每个类是一批具有相同特征的对象的抽象，而系统中所有的类实际上也是实例，
它们都是java.lang.Class的实例。

类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所
有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之
外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。

通过使用不同的类加载器,可以从不同的来源加载类的二进制数据,通常有如下
几种来源：
1）从本地文件系统加载class文件。
2）从JAR包加载class文件。
3）通过网络加载class文件。
4）把一个Java源文件动态编译，并执行加载。
类加载器通常无须等到"首次使用"该类时才加载该类,Java虚拟机规范允许系统
预先加载某些类。

--类的连接
当类被加载之后,系统为之生成一个对应的Class对象,接着将会进入连接阶段,
连接阶段负责把类的二进制数据合并到JRE中。类连接右可分为如下3个阶段：
1）验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类
	协调一致。
2）准备：类准备阶段则负责为类的静态Field分配内存，并设置默认初始值。
3）解析：将类的二进制数据中的符号引用替换成直接引用。

--类的初始化
类的初始化阶段，虚拟机负责对类进行初始化，主要就是对静态Field进行
初始化。在Java类中对静态Field指定初始值有两种方式：
1）声明静态Field时指定初始值。
2）使用静态初始化块为静态Field指定初始值。

JVM初始化一个类包含以下几个步骤：
1）假加入这个类还没有被加载和连接，则程序先加载并连接该类。
2）假如该类的直接父类还没有被初始化，则先初始化其直接父类。
3）假如类中有初始化语句，则系统依次执行这些初始化语句。

当执行第2个步骤时，系统对直接父类的初始化步骤也遵循此步骤1～3；
如果该直接父类又有直接父类，则系统再次重复这3个步骤来先初始化这
个父类……以此类推，所以JVM最先初始化的总是java.lang.Object类。
当程序主动使用任何一个类时，系统会保证该类以及所有父类(包括直接
父类和间接父类)都会被初始化。

--类初始化的时机
当Java程序首次通过下面6种方式来使用某个类或接口时，系统就会初始化
该类或接口。
1）创建类的实例。为某个类创建实例的方式包括：
	1）使用new来创建实例。
	2）通过反射来创建实例。
	3）通过反序列化的方式来创建实例。
2）调用某个类的静态方法。
3）访问某个类或接口的静态Field，或为该静态Field赋值。
4）使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。如：
	Class.forName("Person"),如果系统还未初始化Person类，则这行代码
	将会导致该Person类被初始化，并返回Person类对应的java.lang.Class
	对象。(关于Class的forName方法请参考18.3节)
5）初始化某个类的子类。当初始化某个类的子类时，该子类的所有父类都会被
   初始化。
6）直接使用java.exe命令来运行某个主类。当运行某个主类时，程序会先初始
   化该主类。
	
除此之外，下面几种情形需要特别指出：
1）对于一个final型的静态Field,如果该Field的值在编译时就可以确定下来,
那么这个Field相当于"宏变量"。Java编译器会在编译时直接把这个Field出现
的地方替换为它的值,因此即使程序使用该静态Field,也不会导致该类的初始化
[当某个静态Field使用了final修饰,而且它的值可以在编译时就确定下来,那么
程序其他地方使用该静态Field时,实际上并没有使用该静态Field，而是相当于
使用常量。]
反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行
时才可以确定该Field的值。如果通过该类来访问它的静态Field，则会导致该类
被初始化。
2）当使用ClassLoader类的loadClass()方法来加载某个类时，该方法只是加载
该类，并不会执行该类的初始化。
使用Class的forName()静态方法才会导致强制初始化该类。
----==============================================================
类加载器：
类加载器负责将.class文件(可能在磁盘上，也可能在网络上)加载到内存中，并
为之生成对应的java.lang.Class对象。


